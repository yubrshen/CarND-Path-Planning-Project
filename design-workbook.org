#+LATEX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [koma,DIV=17]
#+LaTeX_CLASS_OPTIONS: [10pt]
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+OPTIONS: toc:nil ^:nil
#+DATE: \today
#+TITLE: Design Workbook for Path Planning

* The definition of data

** Definition of waypoint data
- Waypoint Data
Each waypoint has an (x,y) global map position, and a Frenet s value and Frenet d unit normal vector (split up into the x component, and the y component).

The s value is the distance along the direction of the road. The first waypoint has an s value of 0 because it is the starting point.

The d vector has a magnitude of 1 and points perpendicular to the road in the direction of the right-hand side of the road. The d vector can be used to calculate lane positions. For example, if you want to be in the left lane at some waypoint just add the waypoint's (x,y) coordinates with the d vector multiplied by 2. Since the lane is 4 m wide, the middle of the left lane (the lane closest to the double-yellow diving line) is 2 m from the waypoint.

If you would like to be in the middle lane, add the waypoint's coordinates to the d vector multiplied by 6 = (2+4), since the center of the middle lane is 4 m from the center of the left lane, which is itself 2 m from the double-yellow diving line and the waypoints.
** Definition of sensor_fusion data
The data format for each car is: [ id, x, y, v_x, v_y, s, d]. The id is a unique identifier for that car. The x, y values are in global map coordinates, and the v_x, v_y values are the velocity components, also in reference to the global map. Finally s and d are the Frenet coordinates for that car.

The v_x, v_y values can be useful for predicting where the cars will be in the future. For instance, if you were to assume that the tracked car kept moving along the road, then its future predicted Frenet s value will be its current s value plus its (transformed) total velocity (m/s) multiplied by the time elapsed into the future (s).
* The interface to the simulator

  The path planning module should send to the simulator, the x, y coordinates in interval to drive the car to move to the given coordinates.
  More formal definition is needed here to get the program working.

  The code responsible for driving the simulator:

  #+NAME:driving-simulator
  #+BEGIN_SRC C++ :noweb yes :tangle :exports none

  #+END_SRC
* Design
** Overall design decisions

   - Use meter per seconds to measure speed
     As the measure of distance and speed from fusion data is in meters, and the update interval
     is in seconds (0.02 seconds).
     The exception is the measurement of the speed of "my_car" (the car being controlled),
   it's speed is in mph (mile per hour).

** Control Parameters

   There are mainly two control choices at the each interval (UPDATE_INTERVAL seconds):
   - lane
   - acceleration/deceleration

   Changing lane would be desirable if the controlled car have to severely slowdow or even being crashed in the current line.
   The acceleration/deceleration should be adjusted to be safe, fast and comfortable.

   The seems that changing lane is more fundamental maneuver, I'll focus on it while assuming a constant acceleration/deceleration
   for now. Given the short interval of UPDATE_INTERVAL second control interval, it may be OK to assume small constant acceleration/deceleration.
   The assumption has been partially confirmed in experiment.
   The acceleration/deceleration is assumed to be (+2.24m/s^2 or -2.24/s^2).

   The high level code will reflect two control parameters in anticipation for fuller refined implementation.
** Selection of Lane

   Assuming the acceleration/deceleration controlled to maximize the speed within legal limit, the major consideration of selection of a lane,
   is to avoid collision without too much slowing down. Given other considerations being equal, changing lane may involve additional collision
   risk, and overhead.

   Therefore, the control problem would be modeled by cost function, and the control solution should have the lowest cost among all the legal lane choices.
   The cost function would have the following components:
   - collision cost
   - changing lane cost
*** Collision Cost
    The collision cost reflects the risks of collision.
    The risk of collision has 4 scenarios:
    - Longitudinal collision:
      - collision with the car in front
      - collision by the car in the back
    - Lateral collision:
      - collision by the car in the left
      - collision by the car in the right

    The longitudinal collision can be characterized the overlapping of vehicles' body from the moment of evaluation to the foreseeable future.

*** Changing lane cost

    Changing lane cost may have one major components and one minor component.
    The major components is the lateral collision risk. It will be proportional to the collision cost then.

    The minor component is the overhead and discomfort caused. This is hard to estimate. It will be assumed as a constant for now.

** Avoiding lateral collision and interference

   It's not desirable to be next to another car in the adjacent lane.
   This problem can only solved by adjusting the acceleration/deceleration.
   Thus, this is a case that should be considered with adjustment of acceleration/deceleration.

   It will be less likely, and will be a refinement to do in the future.


* Code

** Decorations
   Necessary decorations to make the code compile.

   #+NAME:decorations
   #+BEGIN_SRC C++ :noweb yes :tangle :exports none
     #include <assert.h> // #include <assert> does not work, why?

     #include <iomanip>

     #include <fstream>

     #include <iostream>

     #include <math.h>
     #include <uWS/uWS.h>
     #include <chrono>
     #include <iostream>
     #include <thread>
     #include <vector>
     #include "Eigen-3.3/Eigen/Core"
     #include "Eigen-3.3/Eigen/QR"
     #include "json.hpp"

     #include "spline.h"
     #include "parameters.h"
     #include "utils.h"

     using namespace std;

     // for convenience
     using json = nlohmann::json;

   #+END_SRC
** Interaction with Simulator
*** check if simulator sends data

** types-related
#+NAME:types-related
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  enum DIRECTION {LEFT = 1, RIGHT = 2};

  enum MANEUVER_STATE {KL=1, LCL=2, LCR=3, PLCL=4, PLCR=5};

#+END_SRC

** car-constants
#+NAME:car-constants
#+BEGIN_SRC C++ :noweb yes :tangle ./src/parameters.h :exports none :main no
  #ifndef PARAMETERS
  #define PARAMETERS

  /*
    parameters.h
    The parameters for path planning design.

  ,*/
  const double METERS_PER_SECOND_IN_MPH = 1609.344/3600;
  double mph_2_meterps(double mph) {
    double meter_per_seconds = mph*METERS_PER_SECOND_IN_MPH;
    return meter_per_seconds;
  }
  const double SPEED_LIMIT = mph_2_meterps(49.0); // mph the top speed allowed
  // const double MINIMUM_SPEED = mph_2_meterps(5.0); // the minimum speed to get moving
  const int NUM_LANES = 3;
  // The max s value before wrapping around the track back to 0
  const double MAX_S = 6945.554;

  const double VEHICLE_LENGTH = 3.0; // meters, 23 meters is the maximum vehicle length, according to California highway standard
  // const double BUFFER_ZONE = 10*VEHICLE_LENGTH;
  const double NEARBY = 1*VEHICLE_LENGTH; // metres, very near to my_car

  const double UPDATE_INTERVAL = 0.02; // seconds, the interval to update maneuver decision

  const int PLANNED_TRAJECTORY_LENGTH = 50; // 3; // the length of the planned trajectory fed to the simulator
  // In the current implementation, PLANNED_TRAJECTORY_LENGTH cannot be larger than 10. It might be a bug in the implementation.
  const int NUM_ADOPTED_REMAINING_TRAJECTORY_POINTS = 50; // 3, 30;
  // the length of the first portion of the remaining trajectory (previous_path)
  // from experiment, it seems 25 might be too few when the CPU is busy.

  const double VELOCITY_INCREMENT_LIMIT = 0.07; // 0.125;

  const double MAX_ACCELERATION_METERS_PER_SECOND_SQUARE = 10; // meter/s^2
  const double MAX_VELOCITY_DELTA_PRE_UPDATE_INTERVAL
  = MAX_ACCELERATION_METERS_PER_SECOND_SQUARE * UPDATE_INTERVAL;
  // const double MAX_VELOCITY_DELTA_PRE_UPDATE_INTERVAL = 0.015; // The above seems too big still

  const double MAX_JERK_METERS_PER_SECOND_CUBIC = 10; // meter/s^3
  const double MAX_ACCELERATION_DELTA_METERS_PER_UPDATE_INTERVAL
  = MAX_JERK_METERS_PER_SECOND_CUBIC * UPDATE_INTERVAL;
  const double COLLISION_C  = .1E6f;
  const double DANGER_C     = .1E7f;
  const double EFFICIENCY_C = .1E3f;
  const double NOT_MIDDLE_C = .1E1f;
  const double LANE_CHANGE_C= .1E4f;
  const double NEAR_ZERO = .1E-1f;
  const double DESIRED_TIME_BUFFER = 10; // seconds, according to http://copradar.com/redlight/factors/ ; change from 30 to 10 for better differentiation
  const double SAFE_DISTANCE = 150.0; // meters, huge number for indefinite futrue time

  const double LANE_CHANGE_INERTIA_C = 1000.0;

  #endif
#+END_SRC

** car-parameters
#+NAME:car-parameters
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  // double ref_val = MAX_VELOCITY_DELTA_PRE_PLANNING_INTERVAL; // initial
  Car my_car;
  my_car.a = 0;
  my_car.jerk = 0;

#+END_SRC
** parse-fusion-data

Need to find the closest vehicle, and also the projected closest distance to the nearest vehicle.

The closest distance to the nearest vehicle would be used to compute the cost of collision and buffer.

The distance would be calculated based on the time horizon when the new trajectory would start to be used, till the end of the new
trajectory.

The need for refined resolution of the distance and the time reaching the threshold.

Simpply considering the shortest distance between two car is not enough. The time to reach the low limit of distance also matter. The sooner to reach, the worst.
So in terms of cost, I can expression the cost inversely proportional to the time reaching the low limit, and the distance at the time.

For the case, when the front car is faster, then the time is at the start of the trajectory, and the distance is at the time of the trajectory start.

For the case, whet the front car is slower, the distance is going to reduce over time further. So I can only measure when the time
the distance becomes not acceptable.

Maybe, I just express the logic in terms of buffer cost directly.

The motivation is to improve the differentiation in the buffer cost for various situations.

One implementation is interpret gap_front, and gap_behind as buffer_cost_coefficients.
It's by default 0. Only when it's bigger than the acceptable distance or sometimes reach the such limit.

#+NAME:parse-fusion-data-declaration
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  // Parse the sensor_fusion data
  string state_str(MANEUVER_STATE state) {
    switch(int(state)) {
    case int(KL):
      return "KL";
    case int(LCL):
      return "LCL";
    case int(LCR):
      return "LCR";
    case int(PLCL):
      return "PLCL";
    case int(PLCR):
      return "PLCR";
    default:
      return "Invalid";
    }
  }
  struct KINEMATIC_DATA {
    double a;
    double v;
    double gap_front;
    double gap_behind;
    double horizon; // evaluation horizon
  };

  struct Decision {
    int    lane_index_changed_to; // note, for prepare to change lane, it's not changed actually
    MANEUVER_STATE maneuver;
    // double velocity_delta;
    double cost;
    KINEMATIC_DATA projected_kinematics; // for key: "velocity", and "acceleration"
  };

  struct Car {
    double id;
    double x;
    double y;
    double yaw;
    double v_x;
    double v_y;
    double s;
    double d;
    double v;
    double remaining_path_end_s;
    double remaining_path_end_d;
    double a;
    double jerk;
    int    lane_index;
    bool   empty;
  };

  struct LaneData {
    Car nearest_front;
    Car nearest_back;
    // double         car_density_front;
    double gap_front; // the projected smallest distance with the car in front, depreciated
    double gap_behind; // the projected smallest distance with the car behind, depreciated
    double congestion_front;      // the congestion with the car in front
    double congestion_behind;     // the congestion with the car behind
  };

  struct DATA_LANES {
    map<int, LaneData> lanes;
    //double projected_duration;
    bool car_to_left = false;
    bool car_to_right = false;
    bool car_crashing_front_or_behind = false;
  };
  struct TRAJECTORY {
    vector<double> x_vals;
    vector<double> y_vals;
  };

  typedef vector< vector<double> > SENSOR_FUSION;
#+END_SRC

#+NAME:parse-fusion-data
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  void update_surronding(Car my_car, double congestion, int lane, DATA_LANES *data_lanes) {
    /*
      Based on the distance between the car in front, and that behind, congestion to determine the car's
      status, represented in the fields of DATA_LANES: car_crashing_front_or_behind, car_to_left, car_to_right.
     ,*/

    data_lanes-> car_crashing_front_or_behind = false;
    data_lanes-> car_to_left                  = false;
    data_lanes-> car_to_right                 = false;
    if (1.0 < congestion) // ((0 <= congestion) && (congestion < NEARBY))
      {
      switch (my_car.lane_index - lane) {
      case 0:
        data_lanes->car_crashing_front_or_behind = true;
        break;
      case 1:
        data_lanes->car_to_left = true;
        break;
      case -1:
        data_lanes->car_to_right = true;
      default:
        break;
      }} else {
      // cout <<"car_{right, left, ahead}: " << data_lanes->car_to_right << ", " << data_lanes->car_to_left << ", " << data_lanes->car_crashing_front_or_behind;
    }
  }

  // Try to avoid division, but use similar logic, to simplify the model
  // To work out,

  // The following should change to buffer_coefficient_f

  double shortest_distance(Car front, Car behind, double start_time, double end_time)
  { // compute the shortest distance between the car in front and the behind from start_time to end_time.
    // To simplify, assume they have zero acceleration
    double dist;
    if (front.v <= behind.v)
      {// the shortest distance would be at the end_time, with the distance will decrease from the start_time to end_time
        dist = (front.s - behind.s) + (front.v - behind.v)*end_time;
      } else
      { // the shortest would be at the start_time
        dist = (front.s - behind.s) + (front.v - behind.v)*start_time;
      }
    return max(dist, 0.0); // ensure that it's non-negative. when it's negative, it's already way too close.
  }

  DATA_LANES parse_sensor_data(Car my_car, SENSOR_FUSION sensor_fusion, double start_time, double end_time)
  { // find the nearest car in front, and behind, and find the smallest (worst) distance with my_car in the time period
    // defined by start and end.

    DATA_LANES data_lanes;
    for (int i = 0; i < NUM_LANES; i++)
      { // initialize the data structure with default values
      LaneData lane_data;
      data_lanes.lanes[i] = lane_data; // assume copy semantics
      data_lanes.lanes[i].nearest_back.empty = true;
      data_lanes.lanes[i].nearest_front.empty = true;
      data_lanes.lanes[i].gap_front  = SAFE_DISTANCE;
      data_lanes.lanes[i].gap_behind = SAFE_DISTANCE;
      data_lanes.lanes[i].congestion_front  = 0.0;
      data_lanes.lanes[i].congestion_behind = 0.0;
      }

    Car a_car;
    for (auto data:sensor_fusion)
      { // find the nearest in front and behind
      a_car.d  = data[6];
      if ((a_car.d < 0) || (lane_width*NUM_LANES < a_car.d))
        {
        continue;
        }
      a_car.id = data[0];
      a_car.x  = data[1];
      a_car.y  = data[2];
      a_car.v_x = data[3];
      a_car.v_y = data[4];
      a_car.s  = data[5];

      a_car.lane_index = d_to_lane_index(a_car.d);
      a_car.v = sqrt(pow(a_car.v_x, 2) + pow(a_car.v_y, 2));
      a_car.empty = false;

      // cout << "a car at lane: " << a_car.lane_index;
      if (a_car.s <= my_car.s) {// there is a car behind
        if (data_lanes.lanes[a_car.lane_index].nearest_back.empty) {
          // cout << ", first registration for nearest_back ";
          data_lanes.lanes[a_car.lane_index].nearest_back       = a_car;
        } else {
          if (data_lanes.lanes[a_car.lane_index].nearest_back.s < a_car.s) {
            data_lanes.lanes[a_car.lane_index].nearest_back = a_car;
            // cout << ", update for nearest_back ";
          }}}
      if (my_car.s <= a_car.s) { // there is a car in front
        if (data_lanes.lanes[a_car.lane_index].nearest_front.empty) {
          // cout << ", first registration for nearest_front ";
          data_lanes.lanes[a_car.lane_index].nearest_front       = a_car;
        } else {
          if (a_car.s < data_lanes.lanes[a_car.lane_index].nearest_front.s) {
            // cout << ", update for nearest_back ";
            data_lanes.lanes[a_car.lane_index].nearest_front = a_car;
          }}}}
    // For only the legal lanes adjacent to my_car.lane_index,
    int left_lane  = my_car.lane_index -1;
    int right_lane = my_car.lane_index +1;
    // cout << "candidates_{left | right}_lane: " << left_lane << " | " << right_lane << "; ";
    vector<int> lanes_interested = {my_car.lane_index};
    if (0 <= left_lane)         lanes_interested.push_back(left_lane);
    if (right_lane < NUM_LANES) lanes_interested.push_back(right_lane);
    for (auto lane:lanes_interested) {
      cout << "interested lane: " << lane << "; ";
      if (!data_lanes.lanes[lane].nearest_back.empty)
        {
          cout << " back congestion: ";
          double congestion = congestion_f(my_car, data_lanes.lanes[lane].nearest_back, start_time, end_time);
            // shortest_distance(my_car, data_lanes.lanes[lane].nearest_back, start_time, end_time);
          // my_car.s - data_lanes.lanes[lane].nearest_back.s;
          data_lanes.lanes[lane].congestion_behind = congestion;
          update_surronding(my_car, congestion, lane, &data_lanes);
        }
      if (!data_lanes.lanes[lane].nearest_front.empty)
        {
          cout << " front congestion: ";
          double congestion = congestion_f(data_lanes.lanes[lane].nearest_front, my_car, start_time, end_time);
            // shortest_distance(data_lanes.lanes[lane].nearest_front, my_car, start_time, end_time);
          // data_lanes.lanes[lane].nearest_front.s - my_car.s;
          data_lanes.lanes[lane].congestion_front = congestion;
          update_surronding(my_car, congestion, lane, &data_lanes);
        }
    }
    return data_lanes;
  }
#+END_SRC
** congestion characterization

   This models the congestion condition between two cars, the front and the behind, on the same lane.

   The function returns the congestion coefficient between the two cars.

   #+NAME:congestion
   #+BEGIN_SRC C++ :noweb yes :tangle :exports none
     double start_distance_congestion(double dist_start)
     {
       return exp(-max(dist_start/SAFE_DISTANCE, 0.0) );
     }

     const double SAFE_DISTANCE_CONGESTION = start_distance_congestion(SAFE_DISTANCE);
     double threshold_congestion(double time_threshold, double start_time)
     {
       double damper = SAFE_DISTANCE_CONGESTION/exp(-start_time);
       // adjust the congestion for this case, to be comparable with that computed by start_distance_congestion
       // if time_threshold == start_time, then the congestion would be equal to start_distance_congestion(SAFE_DISTANCE)
       double c = damper * exp(-time_threshold);
       return c;
     }

     double congestion_f(Car front, Car behind, double start_time, double end_time)
     { // returns the congestion coefficient between the two cars.
       // To simplify, assume they have zero acceleration
       double c = 0.0;
       double dist_start = (front.s - behind.s) + (front.v - behind.v)*start_time;
       if (behind.v <= front.v)
         {
           c = start_distance_congestion(dist_start); //exp(-max(dist_start, 0.0)*start_time);
           cout << " start_time: " << setw(5) << start_time << ", front faster, dist_start: " << setw(7) << dist_start << " c: " << setw(7) << c << "; ";
         } else
         { // behind.v > front.v
           if (dist_start <= SAFE_DISTANCE)
             {
               double punish_weight = 1.01; // punish further this case

               c = punish_weight * start_distance_congestion(dist_start); //exp(-max(dist_start, 0.0)*start_time);
               cout <<  " start_time: " << setw(5) << start_time <<", front slower and start with less safe distance, dist_start: " << setw(7) << dist_start <<  " c: " << setw(7) << c <<"; ";
             } else
             { // dist_start > SAFE_DISTANCE
               // with equation:
               // dist = (front.s - behind.s) + (front.v - behind.v)* t = SAFE_DISTANCE
               double time_threshold = (SAFE_DISTANCE - (front.s - behind.s)) / (front.v - behind.v);
               cout << "front slower, and start wtih more than safe distance, time_threshold: " << setw(7) << time_threshold << " c: " << setw(7) << c <<"; ";

               assert(start_time <= time_threshold); // by the model's reasoning
               c = threshold_congestion(time_threshold, start_time);
             }
         }
       return c;
     }
   #+END_SRC


** support-to-maneuver

#+NAME:support-to-maneuver
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  template <typename T>
  void vector_remove(vector<T> & a_vector, T value) {
    a_vector.erase(std::remove(a_vector.begin(), a_vector.end(), value), a_vector.end());
  }

  template <typename T>
  typename T::iterator min_map_element(T& m) {
    return min_element(m.begin(), m.end(),
                       [](typename T::value_type& l,
                          typename T::value_type& r) -> bool { return l.second.cost < r.second.cost; });
  }

  // constexpr unsigned int str2int(const char* str, int h = 0)
  // {
  //   return !str[h] ? 5381 : (str2int(str, h+1) * 33) ^ str[h];
  // }

#+END_SRC

** interpolate_points_function

#+NAME:interpolate_points_function
    #+BEGIN_SRC C++ :noweb yes :tangle :exports none
  vector<double> interpolate_points(vector<double> pts_x, vector<double> pts_y,
                                    vector<double> eval_at_x) {
    // uses the spline library to interpolate points connecting a series of x and y values
    // output is spline evaluated at each eval_at_x point

    if (pts_x.size() != pts_y.size()) {
      cout << "ERROR! SMOOTHER: interpolate_points size mismatch between pts_x and pts_y" << endl;
      return { 0 };
    }

    tk::spline s;
    s.set_points(pts_x,pts_y);    // currently it is required that X is already sorted
    vector<double> output;
    for (double x: eval_at_x) {
      output.push_back(s(x));
    }
    return output;
  }

  vector<double> interpolate_points(vector<double> pts_x, vector<double> pts_y,
                                    double interval, int output_size) {
    // uses the spline library to interpolate points connecting a series of x and y values
    // output is output_size number of y values beginning at y[0] with specified fixed interval

    if (pts_x.size() != pts_y.size()) {
      cout << "ERROR! SMOOTHER: interpolate_points size mismatch between pts_x and pts_y" << endl;
      return { 0 };
    }

    tk::spline s;
    s.set_points(pts_x,pts_y);    // currently it is required that X is already sorted
    vector<double> output;
    for (int i = 0; i < output_size; i++) {
      output.push_back(s(pts_x[0] + i * interval));
    }
    return output;
  }
    #+END_SRC


** evaluate_decision

*** evaluate_decision

#+NAME:evaluate_decision
#+BEGIN_SRC C++ :noweb yes :tangle :exports none

  Decision evaluate_decision(MANEUVER_STATE proposed_state, Car my_car, DATA_LANES data_lanes) {
    Decision decision = project_maneuver(proposed_state, my_car, data_lanes);
    decision.cost = calculate_cost(decision, my_car, data_lanes);
    return decision;
  }
#+END_SRC

*** project_maneuver:
Compute the decision should the maneuver is performed.

#+NAME:project_maneuver
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  Decision project_maneuver(MANEUVER_STATE proposed_state, Car my_car, DATA_LANES data_lanes) {
    Decision decision;
    int changed_lane = my_car.lane_index;

    switch(int(proposed_state)) {
    case int(KL):
      decision.projected_kinematics = kinematic_required_in_front(my_car, data_lanes, my_car.lane_index);
      decision.lane_index_changed_to = my_car.lane_index;
      break;
    case int(LCL):
      changed_lane = my_car.lane_index-1;
      decision.projected_kinematics = kinematic_required_in_front(my_car, data_lanes, changed_lane);
      decision.lane_index_changed_to = changed_lane;
      break;
    case int(LCR):
      changed_lane = my_car.lane_index+1;
      decision.projected_kinematics = kinematic_required_in_front(my_car, data_lanes, changed_lane);
      decision.lane_index_changed_to = changed_lane;
      break;
    case int(PLCL):
      decision.lane_index_changed_to = my_car.lane_index;
      // no lane change yet, but evaluate with the proposed change
      decision.projected_kinematics = kinematic_required_behind(my_car, data_lanes, my_car.lane_index -1);
      break;
    case int(PLCR):
      decision.lane_index_changed_to = my_car.lane_index;
      // no lane change yet, but evaluate with the proposed change
      decision.projected_kinematics = kinematic_required_behind(my_car, data_lanes, my_car.lane_index +1);
      break;
    default:
      cout << "Not supported proposed state: " << proposed_state << endl;
      break;
    };
    decision.maneuver = proposed_state;
    cout // <<  "prop. man.: "
         << setw(5) << state_str(decision.maneuver) << ", " << " to: " << decision.lane_index_changed_to << ", ";
    return decision;              // this decision's state needs to be evaluated
  }
#+END_SRC
*** kinematic_required_in_front

    It's not reasonable to expect the car to accelerate/deacceleration within one update interval. This is the root cause of
    the car jerks too often. It's reasonable to assume that a car would be able to adjust the speed in a few seconds.
    I'd experiment with 5 seconds. I call this the planning horizon. I should use consistently wherever applicable.
    This is the time period that a reasonable car should be adjust its speed to the range desirable.

    Calculate at the start of new trajectory, the required and permitted (maximum) acceleration and speed.

    I may want to change the gap_front to be constant of the current update

#+NAME:projected_gap
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  // double projected_gap(Car front, Car behind, double delta_t = UPDATE_INTERVAL) {
  //     // ignore accelerations, assuming they are 0, to simplify
  //     return front.s - behind.s + (front.v - behind.v)*delta_t - VEHICLE_LENGTH;
  //   }

  double projected_gap_front(double front_s, double front_v,
                             double behind_s, double behind_v, double behind_a,
                             double delta_t) {
    double gap = front_s - behind_s + (front_v - behind_v)*delta_t +
      - 0.5*behind_a*(delta_t*delta_t) - VEHICLE_LENGTH;
    return gap;
  }

  double projected_gap_behind(double behind_s, double behind_v,
                              double front_s, double front_v, double front_a,
                              double delta_t) {
    double gap = front_s - behind_s + (front_v - behind_v)*delta_t +
      + 0.5*front_a*(delta_t*delta_t) - VEHICLE_LENGTH;
    return gap;
  }
#+END_SRC

#+NAME:kinematic_required_in_front
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  void update_gaps_in_kinematic(Car front, Car my_car, Car behind,
                                double horizon, KINEMATIC_DATA *kinematic) {
    kinematic->horizon = horizon;
    if (behind.empty) {
      kinematic->gap_behind = SAFE_DISTANCE; // extremely large
    } else {
      kinematic->gap_behind =
        projected_gap_behind(behind.s, behind.v, my_car.s, kinematic->v, kinematic->a, kinematic->horizon);
    }
    if (front.empty) {
      kinematic->gap_front = SAFE_DISTANCE; // extremely large
    } else {
      kinematic->gap_front =
        projected_gap_front(front.s, front.v, my_car.s, kinematic->v, kinematic->a, kinematic->horizon);
    }
  }

  const double SPEED_ADJUSTMENT_PERIOD = 30; // seconds
  double const ONE_OVER_ADJUSTMENT_INTERVAL_SQUARE =
    1/(SPEED_ADJUSTMENT_PERIOD * SPEED_ADJUSTMENT_PERIOD);
  double const ONE_OVER_ADJUSTMENT_INTERVAL = 1/SPEED_ADJUSTMENT_PERIOD;

  // KINEMATIC_DATA kinematic_required_in_front
  // (Car my_car, DATA_LANES data_lanes, int lane_changed_to) {
  //   KINEMATIC_DATA kinematic;
  //   // double acceleration;
  //   double extra_speed_allowed = SPEED_LIMIT - my_car.v;
  //   double speed_limit_allowed_acceleration =
  //     extra_speed_allowed * ONE_OVER_ADJUSTMENT_INTERVAL;
  //   double feasible_acceleration;
  //   // double target_v = SPEED_LIMIT;

  //   if (data_lanes.lanes[lane_changed_to].nearest_front.empty) {
  //     feasible_acceleration = speed_limit_allowed_acceleration;
  //     // effective no consideration of the car in frontfs
  //   } else {
  //     double gap_front = data_lanes.lanes[lane_changed_to].nearest_front.s - my_car.s;
  //       // data_lanes.lanes[lane_changed_to].gap_front;
  //     double available_room = gap_front - BUFFER_ZONE;
  //     feasible_acceleration =
  //       available_room * ONE_OVER_ADJUSTMENT_INTERVAL_SQUARE - my_car.v * ONE_OVER_ADJUSTMENT_INTERVAL;
  //   }
  //   if (feasible_acceleration <= 0) {
  //     kinematic.a = feasible_acceleration;
  //     // collision is happening at the time, deceleration immediately
  //     // The time is at the end of the adopted remaining trajectory, and
  //     // the start of new planned trajectory
  //   } else { // 0 < feasible_acceleration
  //     if (speed_limit_allowed_acceleration < 0) { // speeding over limit
  //       double acceleration_delta
  //         = min(fabs(my_car.a - speed_limit_allowed_acceleration),
  //               MAX_ACCELERATION_DELTA_METERS_PER_UPDATE_INTERVAL);
  //       kinematic.a = my_car.a - acceleration_delta;
  //     } else { // 0 <= speed_limit_allowed_acceleration and 0 < feasible_acceleration
  //       kinematic.a
  //         = min(min(speed_limit_allowed_acceleration,
  //                              feasible_acceleration),
  //               my_car.a + MAX_ACCELERATION_DELTA_METERS_PER_UPDATE_INTERVAL);
  //     }}
  //   // Consider the sensed car in front may not be far away
  //   // The Ego's speed shall be at most than that of the car in front
  //   kinematic.v = min(data_lanes.lanes[lane_changed_to].nearest_front.v,
  //                  my_car.v + kinematic.a * UPDATE_INTERVAL); // kinematic.v is used per UPDATE_INTERVAL

  //   update_gaps_in_kinematic(data_lanes.lanes[lane_changed_to].nearest_front,
  //                            my_car,
  //                            data_lanes.lanes[lane_changed_to].nearest_back,
  //                            10*UPDATE_INTERVAL, &kinematic);
  //   return kinematic;
  // }
  KINEMATIC_DATA kinematic_required_in_front
  (Car my_car, DATA_LANES data_lanes, int lane_changed_to) {
    KINEMATIC_DATA kinematic;
    kinematic.v = SPEED_LIMIT; // assuming there is no car in front.
    kinematic.horizon = 200*UPDATE_INTERVAL; // 4 seconds
    double projected_my_car_s    = my_car.s + kinematic.horizon*(my_car.v + kinematic.v)/2;
    double projected_front_car_s
      = data_lanes.lanes[lane_changed_to].nearest_front.s
      + kinematic.horizon*data_lanes.lanes[lane_changed_to].nearest_front.v;
    double gap_front = projected_front_car_s - projected_my_car_s;
    if (!data_lanes.lanes[lane_changed_to].nearest_front.empty && (gap_front < SAFE_DISTANCE)) {
      kinematic.v = data_lanes.lanes[lane_changed_to].nearest_front.v;
    }
    // if (data_lanes.car_crashing_front_or_behind) {
    //   kinematic.v = 0.0;
    // }
    kinematic.a = (kinematic.v - my_car.v)/kinematic.horizon;
    return kinematic;
  }
#+END_SRC

*** kinematic_required_behind

    #+NAME:kinematic_required_behind
    #+BEGIN_SRC C++ :noweb yes :tangle :exports none
      //map<string, double>
      KINEMATIC_DATA kinematic_required_behind
      (Car my_car, DATA_LANES data_lanes, int lane_index) {
        KINEMATIC_DATA kinematic;
        if (data_lanes.lanes[lane_index].nearest_back.empty) {
          kinematic.a = my_car.a;
          kinematic.v = my_car.v;
        } else {
          double gap_behind = my_car.s - data_lanes.lanes[lane_index].nearest_back.s;
          if (gap_behind <= 0) { // invalid with assumption that the other car is behind
            kinematic.a = my_car.a;
            kinematic.v = my_car.v;
          } else {
            double delta_v =
              my_car.v - data_lanes.lanes[lane_index].nearest_back.v;
            double min_acceleration_pushed_by_nearest_back =
              (delta_v*delta_v)/(2*gap_behind);
            kinematic.a =
              min(min_acceleration_pushed_by_nearest_back,
                  my_car.a + MAX_ACCELERATION_DELTA_METERS_PER_UPDATE_INTERVAL);
            kinematic.v = min(data_lanes.lanes[lane_index].nearest_front.v,
                              my_car.v + kinematic.a * UPDATE_INTERVAL); // kinematic.v is used per UPDATE_INTERVAL
          }}
        update_gaps_in_kinematic(data_lanes.lanes[lane_index].nearest_front,
                                 my_car,
                                 data_lanes.lanes[lane_index].nearest_back,
                                 10*UPDATE_INTERVAL, &kinematic);
        return kinematic;
      }
    #+END_SRC

*** calculate_cost
#+NAME:calculate_cost
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  double calculate_cost(Decision decision, Car my_car, DATA_LANES data_lanes) {
    // cout << " lane: " << decision.lane_index_changed_to;
    double collision_cost         = COLLISION_C *   collision_cost_f(decision, my_car, data_lanes);
    double inefficiency_cost      = EFFICIENCY_C *  inefficiency_cost_f(decision, my_car, data_lanes);
    double buffer_cost            = DANGER_C *      buffer_cost_f(decision, my_car, data_lanes);
    double not_middle_cost        = NOT_MIDDLE_C *  not_middle_cost_f(decision, my_car, data_lanes);
    double lane_change_extra_cost = LANE_CHANGE_C * lane_change_extra_cost_f(my_car, decision);
    double cost
      = collision_cost + buffer_cost + inefficiency_cost + not_middle_cost + lane_change_extra_cost;
    cout << "coll. c: " << setw(3) << collision_cost << " buf. c: " << setw(3) << buffer_cost
         << " ineff. c: " << setw(3) << inefficiency_cost << ", ";
    return cost;
  }
#+END_SRC

*** collision_cost

    Use the current acceleration and velocity of my_car to asses collision risk in more realistic than using those the projected ones.

#+NAME:collision_cost
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  vector<double> solv_2nd_degree_poly(double a, double b, double c) {
    double d  = sqrt(b*b -4*a*c);
    double s1 = (-b + d)/(2*a);
    double s2 = (-b - d)/(2*a);
    return {s1, s2};
  }

  double collision_time_in_future(double a, double b, double c, double horizon) {
    vector<double> candidates = solv_2nd_degree_poly(a, b, c);
    double s0 = candidates[0] + horizon;
    double s1 = candidates[1] + horizon;
    double s  = SAFE_DISTANCE;
    if (0 <= s0) {
      s = s0;
    }
    if ((0 <= s1) && (s1 < s)) {
      s = s1;
    }
    return s;
  }

  double collision_cost_f(Decision decision, Car my_car, DATA_LANES data_lanes) {
    double front_collision_cost  = 0;
    double behind_collision_cost = 0;
    double gap_front_0  = SAFE_DISTANCE;
    double gap_behind_0 = SAFE_DISTANCE;

    if (!data_lanes.lanes[decision.lane_index_changed_to].nearest_front.empty) {
      gap_front_0 = (data_lanes.lanes[decision.lane_index_changed_to].nearest_front.s - my_car.s);
    }

    if (!data_lanes.lanes[decision.lane_index_changed_to].nearest_back.empty) {
      gap_behind_0 = (my_car.s - data_lanes.lanes[decision.lane_index_changed_to].nearest_back.s);
    }
    // cout << " lane studied: " << decision.lane_index_changed_to << ", ";

    // if ((SAFE_DISTANCE <= decision.projected_kinematics.gap_front) &&
    //     (SAFE_DISTANCE <= decision.projected_kinematics.gap_behind)) {
    //   // for the case, when there is no car in front or behind
    //   return 0;
    // }
    if (data_lanes.car_crashing_front_or_behind)
      {
        return 1.0;
      } else
      {
        return 0.0;
      }
    // if ((SAFE_DISTANCE <= gap_front_0) &&
    //     (SAFE_DISTANCE <= gap_behind_0)) {
    //   // for the case, when there is no car in front or behind
    //   // cout << "gap_front_0: " << setw(7) << gap_front_0 << "; ";
    //   return 0;
    // }
    // if (gap_front_0  < BUFFER_ZONE ||
    //     gap_behind_0 < BUFFER_ZONE) {
    //   cout << " too close, ";
    //   return 2.0;
    // }

    // evaluate collision risk with the projected accelerate and speed
    // over a period of horizon
    // double a_f = 0.5*decision.projected_kinematics.a;
    // double a_f   = 0.5*my_car.a;
    // // double b_f = decision.projected_kinematics.v
    // double b_f   = my_car.v
    //   - data_lanes.lanes[decision.lane_index_changed_to].nearest_front.v;
    // double c_f   = my_car.s
    //   - data_lanes.lanes[decision.lane_index_changed_to].nearest_front.s + VEHICLE_LENGTH;
    // double front_collision_time
    //   //  = collision_time_in_future(a_f, b_f, c_f, decision.projected_kinematics.horizon);
    //   = collision_time_in_future(a_f, b_f, c_f, 0.0);

    // front_collision_cost = exp(-pow(front_collision_time, 2));
    // cout << " coll. in front in " << front_collision_time << " sec. ";

    // // double a_b = 0.5*decision.projected_kinematics.a;
    // double a_b = 0.5*my_car.a;
    // // double b_b = decision.projected_kinematics.v
    // double b_b = my_car.v
    //   - data_lanes.lanes[decision.lane_index_changed_to].nearest_back.v;
    // double c_b = my_car.s
    //   - data_lanes.lanes[decision.lane_index_changed_to].nearest_back.s - VEHICLE_LENGTH;
    // double behind_collision_time
    //   //  = collision_time_in_future(a_b, b_b, c_b, decision.projected_kinematics.horizon);
    //   = collision_time_in_future(a_b, b_b, c_b, 0.0);
    // behind_collision_cost = exp(-pow(behind_collision_time, 2));
    // // cout << " coll. behind in " << behind_collision_time << " sec. ";

    // double cost = front_collision_cost + 1.0*behind_collision_cost; // rear collision is less risky
    // return cost;
  }

  // I'm confused with case of PLCL, and PLCR, on which lane, the collision risk is accessed?
  // It should be on the current lane, not the contemplating lane.
  // Need to double check.
#+END_SRC

*** inefficiency_cost
#+NAME:inefficiency_cost
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  double inefficiency_cost_f(Decision decision, Car my_car, DATA_LANES data_lanes) {
    double projected_v = decision.projected_kinematics.v;
    // expect the speed can match SPEED_LIMIT in 1 UPDATE_INTERVAL seconds
    // just relatively compare
    double cost = pow((SPEED_LIMIT - projected_v)/SPEED_LIMIT, 2);
    return cost;
  }
#+END_SRC

*** buffer_cost

#+NAME:buffer_cost
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  double buffer_cost_f(Decision decision, Car my_car, DATA_LANES data_lanes)
  { // express the requirements that both the gap_front and gap_behind should be
    // larger or equal to SAFE_DISTANCE.

    // assume gap_front and gap_behind are non-negative
    // double cost_front = 0;
    // if (data_lanes.lanes[my_car.lane_index].gap_front < SAFE_DISTANCE)
    //   {
    //   cost_front = exp(-data_lanes.lanes[my_car.lane_index].gap_front);
    //   }
    // double cost_behind = 0;
    // if (data_lanes.lanes[my_car.lane_index].gap_behind < SAFE_DISTANCE)
    //   {
    //     cost_behind = exp(-data_lanes.lanes[my_car.lane_index].gap_behind);
    //   }
    double cost_front  = data_lanes.lanes[decision.lane_index_changed_to].congestion_front;
    double cost_behind = data_lanes.lanes[decision.lane_index_changed_to].congestion_behind;
    return cost_front + 1.0 * cost_behind; // might want to consider if the gap_front should have bigger weight.
  }
#+END_SRC

calculate_cost:
Considering all possible costs:
- collision
- buffer_cost
- inefficiency_cost
- discomfort_cost (maybe)

add them together.

The data required:
- future speed of my_car with the maneuver, based on the projected acceleration
- distance to the car in front, or behind (closest_approach), based on data_lanes
- the time to collision, based on the projected acceleration and data_lanes


*** not-middle-cost

#+NAME:not-middle-cost
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  double not_middle_cost_f(Decision decision, Car my_car, DATA_LANES data_lanes) {
    // favor the middle lane, to have more options to change lane when needed
    return logistic(fabs(decision.lane_index_changed_to - 2));
  }
#+END_SRC

*** lane_change_extra_cost_f

#+NAME:lane_change_extra_cost_f
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  double lane_change_extra_cost_f(Car my_car, Decision decision) {
    if ((decision.maneuver == LCL) || (decision.maneuver == LCR))
      return exp(-fabs(my_car.v));
    else
      return 0;
  }
#+END_SRC

** main

*** load-waypoint-data

Here are the data from the map file:

  - vector<double> map_waypoints_x;
  - vector<double> map_waypoints_y;
  - vector<double> map_waypoints_s;
  - vector<double> map_waypoints_dx;
  - vector<double> map_waypoints_dy;

#+NAME:load-waypoint-data
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
// Load up map values for waypoint's x,y,s and d normalized normal vectors
  vector<double> map_waypoints_x;
  vector<double> map_waypoints_y;
  vector<double> map_waypoints_s;
  vector<double> map_waypoints_dx;
  vector<double> map_waypoints_dy;

  // Waypoint map to read from
  string map_file_ = "../data/highway_map.csv";
  ifstream in_map_(map_file_.c_str(), ifstream::in);

  string line;
  while (getline(in_map_, line)) {
  	istringstream iss(line);
  	double x;
  	double y;
  	float s;
  	float d_x;
  	float d_y;
  	iss >> x;
  	iss >> y;
  	iss >> s;
  	iss >> d_x;
  	iss >> d_y;
  	map_waypoints_x.push_back(x);
  	map_waypoints_y.push_back(y);
  	map_waypoints_s.push_back(s);
  	map_waypoints_dx.push_back(d_x);
  	map_waypoints_dy.push_back(d_y);
  }
#+END_SRC

*** refine_maps

    Improve the resolution of waypoint maps.

#+NAME:refine_maps
#+BEGIN_SRC C++ :noweb yes :tangle :exports none

  struct WAYPOINTS_MAP {
    vector<double> _x;
    vector<double> _y;
    vector<double> _s;
    vector<double> _dx;
    vector<double> _dy;
  };

  // vector<double> interpolate_points(vector<double> pts_x, vector<double> pts_y,
  //                                   double interval, int output_size) {
  //   // uses the spline library to interpolate points connecting a series of x and y values
  //   // output is output_size number of y values beginning at y[0] with specified fixed interval

  //   if (pts_x.size() != pts_y.size()) {
  //     cout << "ERROR! SMOOTHER: interpolate_points size mismatch between pts_x and pts_y" << endl;
  //     return { 0 };
  //   }

  //   tk::spline s;
  //   s.set_points(pts_x,pts_y);    // currently it is required that X is already sorted
  //   vector<double> output;
  //   for (int i = 0; i < output_size; i++) {
  //     output.push_back(s(pts_x[0] + i * interval));
  //   }
  //   return output;
  // }

  int NUM_WAYPOINTS_BEHIND = 5;
  int NUM_WAYPOINTS_AHEAD  = 5;

  WAYPOINTS_MAP refine_maps_f(Car my_car, vector<double> map_waypoints_x, vector<double> map_waypoints_y, vector<double> map_waypoints_s,
                              vector<double> map_waypoints_dx, vector<double> map_waypoints_dy) {
    // ********************* CONSTRUCT INTERPOLATED WAYPOINTS OF NEARBY AREA **********************
    int num_waypoints = map_waypoints_x.size();
    int next_waypoint_index = NextWaypoint(my_car.x, my_car.y, my_car.yaw,
                                           map_waypoints_x, map_waypoints_y);
    vector<double> coarse_waypoints_s, coarse_waypoints_x, coarse_waypoints_y,
    coarse_waypoints_dx, coarse_waypoints_dy;
    for (int i = -NUM_WAYPOINTS_BEHIND; i < NUM_WAYPOINTS_AHEAD; i++) {
      // for smooting, take so many previous and so many subsequent waypoints
      int idx = (next_waypoint_index+i) % num_waypoints;
      if (idx < 0) {
        // correct for wrap
        idx += num_waypoints;
      }
      // correct for wrap in s for spline interpolation (must be continuous)
      double current_s = map_waypoints_s[idx];
      double base_s    = map_waypoints_s[next_waypoint_index];
      if ((i < 0) && (base_s < current_s)) {
        current_s -= MAX_S;
      }
      if (i > 0 && current_s < base_s) {
        current_s += MAX_S;
      }
      coarse_waypoints_s.push_back(current_s);
      coarse_waypoints_x.push_back(map_waypoints_x[idx]);
      coarse_waypoints_y.push_back(map_waypoints_y[idx]);
      coarse_waypoints_dx.push_back(map_waypoints_dx[idx]);
      coarse_waypoints_dy.push_back(map_waypoints_dy[idx]);
    }

    // extrapolate to higher resolution

    double dist_inc = 0.5; // interpolated parameters, 0.5 meters
    int num_interpolation_points = (coarse_waypoints_s[coarse_waypoints_s.size()-1] - coarse_waypoints_s[0]) / dist_inc;
    // The last s minus the first s, divided by dist_inc, so it's the number of segments of dist_inc, between the beginning and the end.

    WAYPOINTS_MAP refined_maps;
    refined_maps._s.push_back(coarse_waypoints_s[0]);
    for (int i = 1; i < num_interpolation_points; i++) {
      refined_maps._s.push_back(coarse_waypoints_s[0] + i * dist_inc);
    }

    refined_maps._x  = interpolate_points(coarse_waypoints_s, coarse_waypoints_x,  dist_inc, num_interpolation_points);
    refined_maps._y  = interpolate_points(coarse_waypoints_s, coarse_waypoints_y,  dist_inc, num_interpolation_points);
    refined_maps._dx = interpolate_points(coarse_waypoints_s, coarse_waypoints_dx, dist_inc, num_interpolation_points);
    refined_maps._dy = interpolate_points(coarse_waypoints_s, coarse_waypoints_dy, dist_inc, num_interpolation_points);

    // refined_maps._s  = map_waypoints_s;
    // refined_maps._x  = map_waypoints_x;
    // refined_maps._y  = map_waypoints_y;
    // refined_maps._dx = map_waypoints_dx;
    // refined_maps._dy = map_waypoints_dy;

    return refined_maps;
  }

  // Next to resolve the compilation dependency.

#+END_SRC

*** path_plan

Here is the core of the path plan, computing a series of x, y values for the simulator to move to.
#+NAME:path_plan
#+BEGIN_SRC C++ :noweb yes :tangle :exports code
  // Assemble information to call trajectory_f:
  my_car.id = -1; // hopefully impossible id of the other cars
  my_car.x  = car_x;
  my_car.y  = car_y;
  my_car.yaw = deg2rad(car_yaw);

  double old_v = my_car.v;
  my_car.v  = mph_2_meterps(car_speed);
  my_car.s  = wrap_around(car_s);
  my_car.d  = car_d;
  my_car.lane_index = d_to_lane_index(car_d);

  double old_a = my_car.a;
  my_car.a = (my_car.v - old_v)/UPDATE_INTERVAL;

  my_car.jerk = (my_car.a - old_a)/UPDATE_INTERVAL;

  my_car.remaining_path_end_s = wrap_around(remaining_path_end_s);
  my_car.remaining_path_end_d = remaining_path_end_d;

  ios::fmtflags old_settings = cout.flags();
  cout.precision(5);

  TRAJECTORY remaining_trajectory;
  // cout << "rem. p_{x, y}_len: " << remaining_path_x.size() << ", " << remaining_path_y.size() << ", ";
  // transfer to the remaining trajectory from auto type to pair of double<vector>, otherwise, the compiler reject
  // the vector assginment.
  // cout << endl;
  // cout << "remaining x: ";
  for (auto x:remaining_path_x) {
    remaining_trajectory.x_vals.push_back(x);
    // cout << setw(6) << x << ", ";
   }

  //cout << endl;
  //cout << "remaining y: ";
  for (auto y:remaining_path_y) {
    remaining_trajectory.y_vals.push_back(y);
    // cout << setw(6) << y << ", ";
   }

  // cout << endl;

  // remaining_trajectory.x_vals = remaining_path_x;
  // remaining_trajectory.y_vals = remaining_path_y;

  // Fix and refine the waypoint maps to improve the resolution of computing
  // ref_v based on the remaining trajectory, for smoother trajectory planning.

  WAYPOINTS_MAP refined_maps = refine_maps_f(my_car,
                                           map_waypoints_x, map_waypoints_y, map_waypoints_s,
                                           map_waypoints_dx, map_waypoints_dy);
  TRAJECTORY trajectory
  = trajectory_f(my_car, sensor_fusion, remaining_trajectory, refined_maps);

  // // Define the actual (x, y) points in the planner
  // vector<double> next_x_vals;
  // vector<double> next_y_vals;
#+END_SRC

*** trajactory

    Produce the next trajectory to control the car based on the input from the controller.

#+NAME:trajectory
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  TRAJECTORY trajectory_f(Car my_car, SENSOR_FUSION sensor_fusion, TRAJECTORY remaining_trajectory,
                          WAYPOINTS_MAP waypoints_maps) {
    TRAJECTORY trajectory; // the output

    int remaining_path_adopted_size =
      min((int)remaining_trajectory.x_vals.size(), NUM_ADOPTED_REMAINING_TRAJECTORY_POINTS);

    int new_traj_size = PLANNED_TRAJECTORY_LENGTH - remaining_path_adopted_size;
    // cout << " new_traj_size: " << new_traj_size << "; ";

    double start_time = remaining_path_adopted_size * UPDATE_INTERVAL;
    double end_time   = start_time + new_traj_size  * UPDATE_INTERVAL;

    DATA_LANES data_lanes = parse_sensor_data(my_car, sensor_fusion, start_time, end_time);

    Decision decision = maneuver(my_car, data_lanes);

    // default values for the start of the new trajectory, applicable when there is not enough remaining_trajectory
    double start_s   = my_car.s;
    double start_x   = my_car.x;
    double start_y   = my_car.y;
    double start_yaw = my_car.yaw;
    double start_v   = my_car.v;
    double start_d   = my_car.d;
    double start_d_dot = 0;

    // modulate the start values of trajectory by the remaining trajectory:
    if (2 <= remaining_path_adopted_size) {
      // consider current position to be last point of previous path to be kept
      start_x          = remaining_trajectory.x_vals[remaining_path_adopted_size-1];
      start_y          = remaining_trajectory.y_vals[remaining_path_adopted_size-1];
      double start_x2  = remaining_trajectory.x_vals[remaining_path_adopted_size-2];
      double start_y2  = remaining_trajectory.y_vals[remaining_path_adopted_size-2];
      double start_yaw = atan2(start_y-start_y2,
                               start_x-start_x2);
      vector<double> frenet = getFrenet(start_x, start_y, start_yaw, waypoints_maps._x, waypoints_maps._y, waypoints_maps._s);
      start_s = frenet[0];
      start_d = frenet[1];

      // determine dx, dy vector from set of interpoated waypoints, with start_x, start_y as reference point;
      // since interpolated waypoints are ~1m apart and path points tend to be <0.5m apart, these
      // values can be reused for previous two points (and using the previous waypoint data may be
      // more accurate) to calculate vel_s (start_v), vel_d (start_d_dot), acc_s (s_ddot), and acc_d (d_ddot)
      int next_interp_waypoint_index = NextWaypoint(start_x, start_y, start_yaw,
                                                    waypoints_maps._x, waypoints_maps._y);
      double dx = waypoints_maps._dx[next_interp_waypoint_index - 1];
      double dy = waypoints_maps._dy[next_interp_waypoint_index - 1];
      // sx,sy vector is perpendicular to dx,dy
      double sx = -dy;
      double sy = dx;

      // calculate start_v & start_d_dot
      double vel_x1 = (start_x - start_x2) / UPDATE_INTERVAL;
      double vel_y1 = (start_y - start_y2) / UPDATE_INTERVAL;
      // want projection of xy velocity vector (V) onto S (sx,sy) and D (dx,dy) vectors, and since S
      // and D are unit vectors this is simply the dot products of V with S and V with D
      start_v = vel_x1 * sx + vel_y1 * sy;
      start_d_dot = vel_x1 * dx + vel_y1 * dy;

      // have to get another point to calculate s_ddot, d_ddot from xy acceleration
      // start_x3 = remaining_trajectory.x_vals[remaining_path_adopted_size-3];
      // start_y3 = remaining_trajectory.y_vals[remaining_path_adopted_size-3];
      // vel_x2 = (start_x2 - start_x3) / UPDATE_INTERVAL;
      // vel_y2 = (start_y2 - start_y3) / UPDATE_INTERVAL;
      // acc_x = (vel_x1 - vel_x2) / UPDATE_INTERVAL;
      // acc_y = (vel_y1 - vel_y2) / UPDATE_INTERVAL;
      // s_ddot = acc_x * sx + acc_y * sy;
      // d_ddot = acc_x * dx + acc_y * dy;
    }

    // ********************* PRODUCE NEW PATH ***********************
    // begin by pushing the last and next-to-last point from the previous path for setting the
    // spline the last point should be the first point in the returned trajectory, but because of
    // imprecision, also add that point manually

    vector<double>
      coarse_s_traj, coarse_x_traj, coarse_y_traj,
      interpolated_s_traj, interpolated_x_traj, interpolated_y_traj;

    double prev_s = wrap_around(start_s - start_v * UPDATE_INTERVAL);

    // first two points of coarse trajectory, to ensure spline begins smoothly
    if (2 <= remaining_path_adopted_size) {
      coarse_s_traj.push_back(prev_s);
      coarse_x_traj.push_back(remaining_trajectory.x_vals[remaining_path_adopted_size-2]);
      coarse_y_traj.push_back(remaining_trajectory.y_vals[remaining_path_adopted_size-2]);

      coarse_s_traj.push_back(start_s);
      coarse_x_traj.push_back(remaining_trajectory.x_vals[remaining_path_adopted_size-1]);
      coarse_y_traj.push_back(remaining_trajectory.y_vals[remaining_path_adopted_size-1]);
    } else {
      double prev_s = wrap_around(start_s - 1);
      double prev_x = start_x - cos(start_yaw);
      double prev_y = start_y - sin(start_yaw);

      coarse_s_traj.push_back(prev_s);
      coarse_x_traj.push_back(prev_x);
      coarse_y_traj.push_back(prev_y);

      coarse_s_traj.push_back(start_s);
      coarse_x_traj.push_back(start_x);
      coarse_y_traj.push_back(start_y);
    }

    // last two points of coarse trajectory, use target_d and current s + 30,60
    double target_s1 = wrap_around(start_s + 30);
    double target_d1 = lane_center_d(decision.lane_index_changed_to);
    vector<double> target_xy1 = getXY(target_s1, target_d1, waypoints_maps._s, waypoints_maps._x, waypoints_maps._y);
    double target_x1 = target_xy1[0];
    double target_y1 = target_xy1[1];
    coarse_s_traj.push_back(target_s1);
    coarse_x_traj.push_back(target_x1);
    coarse_y_traj.push_back(target_y1);

    double target_s2 = wrap_around(target_s1 + 30);
    double target_d2 = target_d1;
    vector<double> target_xy2 = getXY(target_s2, target_d2, waypoints_maps._s, waypoints_maps._x, waypoints_maps._y);
    double target_x2 = target_xy2[0];
    double target_y2 = target_xy2[1];
    coarse_s_traj.push_back(target_s2);
    coarse_x_traj.push_back(target_x2);
    coarse_y_traj.push_back(target_y2);

    // next s values
    double target_v = decision.projected_kinematics.v; // best_target[0][1];
    double next_s = start_s;
    double prev_updated_s = -MAX_S; // impossibly small

    double next_v = start_v;
    const double VELOCITY_INCREMENT_LIMIT = 0.125;
    cout << " next_v: ";
    for (int i = 0; i < new_traj_size; i++) {
      double v_incr = 0;
      next_s += next_v * UPDATE_INTERVAL;
      // prevent non-increasing s values:
      next_s = wrap_around(next_s);
      if (next_s <= prev_updated_s)
        break;
      prev_updated_s = next_s;
      cout << setw(5) << next_v << ", ";
      interpolated_s_traj.push_back(next_s);
      if (fabs(target_v - next_v) < 2 * VELOCITY_INCREMENT_LIMIT) {
        v_incr = 0;
      } else {
        // arrived at VELOCITY_INCREMENT_LIMIT value empirically
        v_incr = (target_v - next_v)/(fabs(target_v - next_v)) * VELOCITY_INCREMENT_LIMIT;
      }
      next_v += v_incr;
    }

    interpolated_x_traj = interpolate_points(coarse_s_traj, coarse_x_traj, interpolated_s_traj);
    interpolated_y_traj = interpolate_points(coarse_s_traj, coarse_y_traj, interpolated_s_traj);

    // add previous path, if any, to next path
    // Start with all of the previous path points from last time
    for (int i = 0; i < remaining_path_adopted_size; i++) {
      trajectory.x_vals.push_back(remaining_trajectory.x_vals[i]);
      trajectory.y_vals.push_back(remaining_trajectory.y_vals[i]);
    }

    // add xy points from newly generated path
    // Fill up the rest of the points for the planner
    for (int i = 0; i < interpolated_s_traj.size(); i++) {
      trajectory.x_vals.push_back(interpolated_x_traj[i]);
      trajectory.y_vals.push_back(interpolated_y_traj[i]);
    }
    return trajectory;
  }
#+END_SRC

*** maneuver

The structure Decision represent all the consequence of a maneuver decision including
- the targeted acceleration,
- lane changed into, etc.

#+NAME:maneuver
#+BEGIN_SRC C++ :noweb no :tangle :exports none
  Decision maneuver(Car my_car, DATA_LANES data_lanes) {
    vector<MANEUVER_STATE> states;
    if (!data_lanes.car_crashing_front_or_behind) {
      states.push_back(KL);
    }
    // starting from 0, from the left most to the right most
    if (0 < my_car.lane_index) {// change to left lane possible
      // states.push_back(LCL);
      if (!data_lanes.car_to_left) {
        states.push_back(LCL);
      }
      //states.push_back(PLCL); // put PLCx after LCx in favor of LCx when the cost is equal
    }
    if (my_car.lane_index < NUM_LANES-1) { // change to right lane possible
      // states.push_back(LCR);
      if (!data_lanes.car_to_right) {
        states.push_back(LCR);
      }
      //states.push_back(PLCR); // put PLCx after LCx in favor of LCx when the cost is equal
    }
    map<MANEUVER_STATE, Decision> decisions;
    for (auto proposed_state:states) {
      Decision a_decision = evaluate_decision(proposed_state, my_car, data_lanes);
      cout << setw(5) << state_str(proposed_state) << ", cost: " << setw(5) <<  a_decision.cost << " | ";
      decisions[proposed_state] = a_decision;
    }

    Decision decision = min_map_element(decisions)->second;
    // if ((decision.maneuver != KL) && decisions[KL].cost == decisions[decision.maneuver].cost) {
    //   decision = decisions[KL];
    // }
    cout << "Sel. man.: "  << setw(5) << state_str(decision.maneuver); // << ", cost: " << setw(7) << decision.cost << " ";
    cout << endl; // end of displaying cost evaluations
    return decision;
  }

  // for (size_t i = 0; i < sensor_fusion.size(); i++) {
  //   // car in in my lane
  //   float d = sensor_fusion[i][6];
  //   // the format of sensor_fusion data: vector of vector of id, x, y, v_x, v_y, s, d
  //   if (within_lane(lane_index, d)) {
  //     double v_x = sensor_fusion[i][3];
  //     double v_y = sensor_fusion[i][4];
  //     double another_car_speed = sqrt(v_x*v_x + v_y*v_y);
  //     double another_car_projected_s =
  //       (double)sensor_fusion[i][5] + ((double)remaining_path_adopted_size*UPDATE_INTERVAL*another_car_speed);
  //     // the position of the other car in the slight future
  //     if ((car_s < another_car_projected_s) &&
  //         ((another_car_projected_s - car_s) < 30)) {
  //       // the other car is in front, and too close, within 30 meters distance
  //       // lower reference velocity so my car dosen't crash into the car in front
  //       // could flag to try to change lane
  //       // ref_val = 29.5; // mph
  //       too_close = true;

  //       if (lane_index > 0) {
  //         lane_index = 0;
  //       }
  //     }
  //   }
  //  }
  // // end of rear collision

  // // incremental acceleration/deacceleration

  // if (too_close && (0 < ref_val)) {
  //   ref_val -= 0.224; // roughly equivalent to deacceleration 5m/s^2
  //   // cout << "ref_val: " << ref_val << endl;
  //  } else if (ref_val < SPEED_LIMIT) {
  //   ref_val += 0.224; // roughly equivalent to acceleration 5m/s^2
  //   // cout << "ref_val: " << ref_val << endl;
  //  }
  // // end of acceleration/deacceleration
#+END_SRC

*** onHttpRequest

#+NAME:onHttpRequest
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
  // We don't need this since we're not using HTTP but if it's removed the
  // program
  // doesn't compile :-(
  h.onHttpRequest([](uWS::HttpResponse *res, uWS::HttpRequest req, char *data,
                     size_t, size_t) {
    const std::string s = "<h1>Hello world!</h1>";
    if (req.getUrl().valueLength == 1) {
      res->end(s.data(), s.length());
    } else {
      // i guess this should be done more gracefully?
      res->end(nullptr, 0);
    }
  });
#+END_SRC
*** Connection and Disconnection Handling

#+NAME:on_connection_handling
#+BEGIN_SRC C++ :noweb yes :tangle :exports none
h.onConnection([&h](uWS::WebSocket<uWS::SERVER> ws, uWS::HttpRequest req) {
    std::cout << "Connected!!!" << std::endl;
  });

  h.onDisconnection([&h](uWS::WebSocket<uWS::SERVER> ws, int code,
                         char *message, size_t length) {
    ws.close();
    std::cout << "Disconnected" << std::endl;
  });
#+END_SRC

*** main
#+NAME:main.cpp
#+BEGIN_SRC C++ :noweb yes :tangle ./src/main.cpp :exports none
  <<decorations>>
  <<types-related>>
  <<interpolate_points_function>>
  <<parse-fusion-data-declaration>>
  <<projected_gap>>
  <<congestion>>
  <<parse-fusion-data>>
  <<support-to-maneuver>>
  <<lane_keep_cost>>
  <<lane_change_cost>>
  <<kinematic_required_in_front>>
  <<kinematic_required_behind>>
  <<project_maneuver>>
  <<logistic>>
  <<collision_cost>>
  <<buffer_cost>>
  <<inefficiency_cost>>
  <<not-middle-cost>>
  <<lane_change_extra_cost_f>>
  <<calculate_cost>>
  <<evaluate_decision>>
  <<maneuver>>
  <<refine_maps>>
  <<trajectory>>

  int main() {
    <<load-waypoint-data>>
    <<car-parameters>>

    int update_count = 0; // used to debug to capture the first trace
    uWS::Hub h;
    h.onMessage([&map_waypoints_x, &map_waypoints_y, &map_waypoints_s, &map_waypoints_dx, &map_waypoints_dy,
                 &my_car,
                 &update_count]
                (uWS::WebSocket<uWS::SERVER> ws, char *data, size_t length, uWS::OpCode opCode) {
      // "42" at the start of the message means there's a websocket message event.
      // The 4 signifies a websocket message
      // The 2 signifies a websocket event
      //auto sdata = string(data).substr(0, length);
      //cout << sdata << endl;
      if (length && length > 2 && data[0] == '4' && data[1] == '2') {
        auto s = hasData(data);
        if (s != "") {
          auto j = json::parse(s);
          string event = j[0].get<string>();

          if (event == "telemetry") {
            // j[1] is the data JSON object
            // Main car's localization Data
              double car_x = j[1]["x"];
              double car_y = j[1]["y"];
              double car_s = j[1]["s"];
              double car_d = j[1]["d"];
              double car_yaw = j[1]["yaw"]; // in degree
              double car_speed = j[1]["speed"]; // in mile per hour

              // Previous path data given to the Planner
              // actually they are the remaining points of trajectory not yet visited by the car
              // they are issued by the path planner to the car in the previous control time
              auto remaining_path_x = j[1]["previous_path_x"];
              auto remaining_path_y = j[1]["previous_path_y"];
              // Previous path's end s and d values
              double remaining_path_end_s = j[1]["end_path_s"]; // not yet used, keep for documentation purpose
              double remaining_path_end_d = j[1]["end_path_d"]; // not yet used, keep might be needed

              cout << "car_s|d: " << setw(7) << car_s << " | " << setw(7) << car_d << "; ";

              // << " car_x|y: " << setw(7)<< car_x << " | " << setw(7)<< car_y << " remaining_path_end_s|d: "<< setw(7)
              // << remaining_path_end_s << " | " << setw(7)<< remaining_path_end_d << " car_speed (meters/s) " << mph_2_meterps(car_speed)
              // << endl;

              // cout << "car_s: " << car_s << ", car_{x, y}: " << car_x << ", " << car_y << " remaining_path_end_{s, d}: "
              //      << remaining_path_end_s << ", " << remaining_path_end_d << " car_speed (meters/s) " << mph_2_meterps(car_speed)
              //      << endl;

              // Sensor Fusion Data, a list of all other cars on the same side of the road.
              auto sensor_fusion = j[1]["sensor_fusion"];

              <<path_plan>>

              // cout << endl;
              // cout << "planned traj. sent to simulator" << endl;
              // cout << "x: ";
              // for (auto x:trajectory.x_vals) {
              //   cout << setw(6) << x << ", ";
              // }
              // cout << endl;
              // cout << "y: ";
              // for (auto y:trajectory.y_vals) {
              //   cout << setw(6) << y << ", ";
              // }
              // cout << endl;

              json msgJson;
              msgJson["next_x"] = trajectory.x_vals;
              msgJson["next_y"] = trajectory.y_vals;

              auto msg = "42[\"control\","+ msgJson.dump()+"]";

              //this_thread::sleep_for(chrono::milliseconds(1000));
              ws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);
          }
        } else {
          // Manual driving
          std::string msg = "42[\"manual\",{}]";
          ws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);
        }
      }
    });

    <<onHttpRequest>>

       <<on_connection_handling>>

       int port = 4567;
    if (h.listen(port)) {
      std::cout << "Listening to port " << port << std::endl;
    } else {
      std::cerr << "Failed to listen to port" << std::endl;
      return -1;
    }
    h.run();
  }
#+END_SRC

* Reminder: need to deal with case when there is no car in front or back
  Here are the cases that I have considered:
  - acceleration_required_behind
  - acceleration_required_in_front
  - collision_cost
  - buffer_cost
  -

    The inefficiency cost should not have dependancy to cars in front or behind.

* Whether I should make data lanes persistent to achieve acceleration and data smoothing?


* Done

Add the design of using the first part of the remaining trajectory, and the associated time delay.

Note, in my implementation, I might need to introduce the concept and value of the start of new trajectory,
  as I'm using the first part of remaining trajectory, which takes some time, thus the position of the other vehicles,
as well as Ego's new trajectory should start at the time after those adopted remaining trajectory being used up.
  Each point in the trajectory spans UPDATE_INTERVAL, then the time it would be:
  UPDATE_INTERVAL * NUM_ADOPTED_REMAINING_TRAJECTORY_POINTS

Note, the concept of PLANNING horizon may need to be questioned, I revert back the preference of using UPDATE_INTERVAL as the base.

Note, I may need to evaluate the cost/risk in terms of multiple interval of horizon, beyond just one interval.
This might be the intuition of "PLANNING" concept. But it's not just not large interval of PLANNING.

The current approach of using initial speed of ref_val to create the spacing in the trajectory, especially assume that the speed is
constant! The example's approach might be more reasonable.

* Todo

Now the problem of not considering to change the lanes has been solved.

There is another problem that it hesitate to change lane, and may not determined to change.
Also the lane line is not quite persistent.

May need to consider the duration to be larger to provide more realistic view of the surrounding.
Need to fix the problem that the maneuver selection does not make sense, by reviewing the cost functions' design.
